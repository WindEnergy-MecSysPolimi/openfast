!STARTOFREGISTRYGENERATEDFILE 'IfW_UserWind_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! IfW_UserWind_Types
!.................................................................................................................................
! This file is part of IfW_UserWind.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in IfW_UserWind. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE IfW_UserWind_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  IfW_UserWind_InitInputType  =======
  TYPE, PUBLIC :: IfW_UserWind_InitInputType
    CHARACTER(1024)  :: WindFileName      !< Name of the wind file to use [-]
    CHARACTER(1024)  :: LayoutFileName      !< Name of the layout file to use [-]
    CHARACTER(1024)  :: FlorisFileName      !< Name of the layout file to use [-]
  END TYPE IfW_UserWind_InitInputType
! =======================
! =========  IfW_UserWind_InitOutputType  =======
  TYPE, PUBLIC :: IfW_UserWind_InitOutputType
    TYPE(ProgDesc)  :: Ver      !< Version information off HHWind submodule [-]
  END TYPE IfW_UserWind_InitOutputType
! =======================
! =========  IfW_UserWind_MiscVarType  =======
  TYPE, PUBLIC :: IfW_UserWind_MiscVarType
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: AllInAD      !< All Inputs arriving from Aerodyn at time step t [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: BlPos      !< All Nodes Blades arriving from Aerodyn at time step t [-]
    INTEGER(IntKi) , DIMENSION(:), ALLOCATABLE  :: BlOutNd      !< All Nodes Blades arriving from Aerodyn at time step t [-]
    REAL(ReKi)  :: YawAngle      !< All Inputs arriving from Servofyn at time step t [-]
  END TYPE IfW_UserWind_MiscVarType
! =======================
! =========  IfW_UserWind_ParameterType  =======
  TYPE, PUBLIC :: IfW_UserWind_ParameterType
    REAL(ReKi)  :: dT      !< Time Step [-]
    REAL(ReKi)  :: Ttot      !< Time Total Simulation [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Vb      !< Basic Wind Intensity [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: z0      !< terrain roughness [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: zmin      !< Minimum terrain height [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WindDir      !< Wind Direction [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WindVeer      !< Wind Veer [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Tint      !< Wind Veer [-]
    REAL(ReKi)  :: ka      !< Wake par 1 [-]
    REAL(ReKi)  :: kb      !< Wake par 2 [-]
    REAL(ReKi)  :: alpha      !< Wake par 3 [-]
    REAL(ReKi)  :: beta      !< Wake par 4 [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: zhub      !< Hub height various turbines [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: drot      !< Rotor diameter various turbines [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ti_par      !< turbulence intensity parameters [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Layout      !< Layout of Wind Farm [-]
    INTEGER(IntKi)  :: NumDataLines      !< Number data lines in file wind [-]
  END TYPE IfW_UserWind_ParameterType
! =======================
CONTAINS
 SUBROUTINE IfW_UserWind_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(IfW_UserWind_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(IfW_UserWind_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'IfW_UserWind_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%WindFileName = SrcInitInputData%WindFileName
    DstInitInputData%LayoutFileName = SrcInitInputData%LayoutFileName
    DstInitInputData%FlorisFileName = SrcInitInputData%FlorisFileName
 END SUBROUTINE IfW_UserWind_CopyInitInput

 SUBROUTINE IfW_UserWind_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(IfW_UserWind_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'IfW_UserWind_DestroyInitInput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE IfW_UserWind_DestroyInitInput

 SUBROUTINE IfW_UserWind_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(IfW_UserWind_InitInputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'IfW_UserWind_PackInitInput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%WindFileName)  ! WindFileName
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%LayoutFileName)  ! LayoutFileName
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%FlorisFileName)  ! FlorisFileName
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

        DO I = 1, LEN(InData%WindFileName)
          IntKiBuf(Int_Xferred) = ICHAR(InData%WindFileName(I:I), IntKi)
          Int_Xferred = Int_Xferred   + 1
        END DO ! I
        DO I = 1, LEN(InData%LayoutFileName)
          IntKiBuf(Int_Xferred) = ICHAR(InData%LayoutFileName(I:I), IntKi)
          Int_Xferred = Int_Xferred   + 1
        END DO ! I
        DO I = 1, LEN(InData%FlorisFileName)
          IntKiBuf(Int_Xferred) = ICHAR(InData%FlorisFileName(I:I), IntKi)
          Int_Xferred = Int_Xferred   + 1
        END DO ! I
 END SUBROUTINE IfW_UserWind_PackInitInput

 SUBROUTINE IfW_UserWind_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(IfW_UserWind_InitInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'IfW_UserWind_UnPackInitInput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      DO I = 1, LEN(OutData%WindFileName)
        OutData%WindFileName(I:I) = CHAR(IntKiBuf(Int_Xferred))
        Int_Xferred = Int_Xferred   + 1
      END DO ! I
      DO I = 1, LEN(OutData%LayoutFileName)
        OutData%LayoutFileName(I:I) = CHAR(IntKiBuf(Int_Xferred))
        Int_Xferred = Int_Xferred   + 1
      END DO ! I
      DO I = 1, LEN(OutData%FlorisFileName)
        OutData%FlorisFileName(I:I) = CHAR(IntKiBuf(Int_Xferred))
        Int_Xferred = Int_Xferred   + 1
      END DO ! I
 END SUBROUTINE IfW_UserWind_UnPackInitInput

 SUBROUTINE IfW_UserWind_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(IfW_UserWind_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(IfW_UserWind_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'IfW_UserWind_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
      CALL NWTC_Library_Copyprogdesc( SrcInitOutputData%Ver, DstInitOutputData%Ver, CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
 END SUBROUTINE IfW_UserWind_CopyInitOutput

 SUBROUTINE IfW_UserWind_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(IfW_UserWind_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'IfW_UserWind_DestroyInitOutput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
  CALL NWTC_Library_Destroyprogdesc( InitOutputData%Ver, ErrStat, ErrMsg )
 END SUBROUTINE IfW_UserWind_DestroyInitOutput

 SUBROUTINE IfW_UserWind_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(IfW_UserWind_InitOutputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'IfW_UserWind_PackInitOutput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
      Int_BufSz   = Int_BufSz + 3  ! Ver: size of buffers for each call to pack subtype
      CALL NWTC_Library_Packprogdesc( Re_Buf, Db_Buf, Int_Buf, InData%Ver, ErrStat2, ErrMsg2, .TRUE. ) ! Ver 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! Ver
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! Ver
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! Ver
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      CALL NWTC_Library_Packprogdesc( Re_Buf, Db_Buf, Int_Buf, InData%Ver, ErrStat2, ErrMsg2, OnlySize ) ! Ver 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
 END SUBROUTINE IfW_UserWind_PackInitOutput

 SUBROUTINE IfW_UserWind_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(IfW_UserWind_InitOutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'IfW_UserWind_UnPackInitOutput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL NWTC_Library_Unpackprogdesc( Re_Buf, Db_Buf, Int_Buf, OutData%Ver, ErrStat2, ErrMsg2 ) ! Ver 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
 END SUBROUTINE IfW_UserWind_UnPackInitOutput

 SUBROUTINE IfW_UserWind_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(IfW_UserWind_MiscVarType), INTENT(IN) :: SrcMiscData
   TYPE(IfW_UserWind_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'IfW_UserWind_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcMiscData%AllInAD)) THEN
  i1_l = LBOUND(SrcMiscData%AllInAD,1)
  i1_u = UBOUND(SrcMiscData%AllInAD,1)
  IF (.NOT. ALLOCATED(DstMiscData%AllInAD)) THEN 
    ALLOCATE(DstMiscData%AllInAD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%AllInAD.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%AllInAD = SrcMiscData%AllInAD
ENDIF
IF (ALLOCATED(SrcMiscData%BlPos)) THEN
  i1_l = LBOUND(SrcMiscData%BlPos,1)
  i1_u = UBOUND(SrcMiscData%BlPos,1)
  i2_l = LBOUND(SrcMiscData%BlPos,2)
  i2_u = UBOUND(SrcMiscData%BlPos,2)
  IF (.NOT. ALLOCATED(DstMiscData%BlPos)) THEN 
    ALLOCATE(DstMiscData%BlPos(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BlPos.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BlPos = SrcMiscData%BlPos
ENDIF
IF (ALLOCATED(SrcMiscData%BlOutNd)) THEN
  i1_l = LBOUND(SrcMiscData%BlOutNd,1)
  i1_u = UBOUND(SrcMiscData%BlOutNd,1)
  IF (.NOT. ALLOCATED(DstMiscData%BlOutNd)) THEN 
    ALLOCATE(DstMiscData%BlOutNd(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%BlOutNd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%BlOutNd = SrcMiscData%BlOutNd
ENDIF
    DstMiscData%YawAngle = SrcMiscData%YawAngle
 END SUBROUTINE IfW_UserWind_CopyMisc

 SUBROUTINE IfW_UserWind_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(IfW_UserWind_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'IfW_UserWind_DestroyMisc'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(MiscData%AllInAD)) THEN
  DEALLOCATE(MiscData%AllInAD)
ENDIF
IF (ALLOCATED(MiscData%BlPos)) THEN
  DEALLOCATE(MiscData%BlPos)
ENDIF
IF (ALLOCATED(MiscData%BlOutNd)) THEN
  DEALLOCATE(MiscData%BlOutNd)
ENDIF
 END SUBROUTINE IfW_UserWind_DestroyMisc

 SUBROUTINE IfW_UserWind_PackMisc( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(IfW_UserWind_MiscVarType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'IfW_UserWind_PackMisc'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! AllInAD allocated yes/no
  IF ( ALLOCATED(InData%AllInAD) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! AllInAD upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%AllInAD)  ! AllInAD
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlPos allocated yes/no
  IF ( ALLOCATED(InData%BlPos) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! BlPos upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%BlPos)  ! BlPos
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! BlOutNd allocated yes/no
  IF ( ALLOCATED(InData%BlOutNd) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! BlOutNd upper/lower bounds for each dimension
      Int_BufSz  = Int_BufSz  + SIZE(InData%BlOutNd)  ! BlOutNd
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! YawAngle
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%AllInAD) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%AllInAD,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%AllInAD,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%AllInAD)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%AllInAD))-1 ) = PACK(InData%AllInAD,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%AllInAD)
  END IF
  IF ( .NOT. ALLOCATED(InData%BlPos) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlPos,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlPos,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlPos,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlPos,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%BlPos)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%BlPos))-1 ) = PACK(InData%BlPos,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%BlPos)
  END IF
  IF ( .NOT. ALLOCATED(InData%BlOutNd) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%BlOutNd,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%BlOutNd,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%BlOutNd)>0) IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(InData%BlOutNd))-1 ) = PACK(InData%BlOutNd,.TRUE.)
      Int_Xferred   = Int_Xferred   + SIZE(InData%BlOutNd)
  END IF
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%YawAngle
      Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE IfW_UserWind_PackMisc

 SUBROUTINE IfW_UserWind_UnPackMisc( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(IfW_UserWind_MiscVarType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'IfW_UserWind_UnPackMisc'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! AllInAD not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%AllInAD)) DEALLOCATE(OutData%AllInAD)
    ALLOCATE(OutData%AllInAD(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%AllInAD.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%AllInAD)>0) OutData%AllInAD = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%AllInAD))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%AllInAD)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlPos not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlPos)) DEALLOCATE(OutData%BlPos)
    ALLOCATE(OutData%BlPos(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlPos.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%BlPos)>0) OutData%BlPos = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%BlPos))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%BlPos)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! BlOutNd not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%BlOutNd)) DEALLOCATE(OutData%BlOutNd)
    ALLOCATE(OutData%BlOutNd(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%BlOutNd.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%BlOutNd)>0) OutData%BlOutNd = UNPACK( IntKiBuf ( Int_Xferred:Int_Xferred+(SIZE(OutData%BlOutNd))-1 ), mask1, 0_IntKi )
      Int_Xferred   = Int_Xferred   + SIZE(OutData%BlOutNd)
    DEALLOCATE(mask1)
  END IF
      OutData%YawAngle = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
 END SUBROUTINE IfW_UserWind_UnPackMisc

 SUBROUTINE IfW_UserWind_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(IfW_UserWind_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(IfW_UserWind_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'IfW_UserWind_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%dT = SrcParamData%dT
    DstParamData%Ttot = SrcParamData%Ttot
IF (ALLOCATED(SrcParamData%Vb)) THEN
  i1_l = LBOUND(SrcParamData%Vb,1)
  i1_u = UBOUND(SrcParamData%Vb,1)
  IF (.NOT. ALLOCATED(DstParamData%Vb)) THEN 
    ALLOCATE(DstParamData%Vb(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Vb.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Vb = SrcParamData%Vb
ENDIF
IF (ALLOCATED(SrcParamData%z0)) THEN
  i1_l = LBOUND(SrcParamData%z0,1)
  i1_u = UBOUND(SrcParamData%z0,1)
  IF (.NOT. ALLOCATED(DstParamData%z0)) THEN 
    ALLOCATE(DstParamData%z0(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%z0.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%z0 = SrcParamData%z0
ENDIF
IF (ALLOCATED(SrcParamData%zmin)) THEN
  i1_l = LBOUND(SrcParamData%zmin,1)
  i1_u = UBOUND(SrcParamData%zmin,1)
  IF (.NOT. ALLOCATED(DstParamData%zmin)) THEN 
    ALLOCATE(DstParamData%zmin(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%zmin.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%zmin = SrcParamData%zmin
ENDIF
IF (ALLOCATED(SrcParamData%WindDir)) THEN
  i1_l = LBOUND(SrcParamData%WindDir,1)
  i1_u = UBOUND(SrcParamData%WindDir,1)
  IF (.NOT. ALLOCATED(DstParamData%WindDir)) THEN 
    ALLOCATE(DstParamData%WindDir(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WindDir.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%WindDir = SrcParamData%WindDir
ENDIF
IF (ALLOCATED(SrcParamData%WindVeer)) THEN
  i1_l = LBOUND(SrcParamData%WindVeer,1)
  i1_u = UBOUND(SrcParamData%WindVeer,1)
  IF (.NOT. ALLOCATED(DstParamData%WindVeer)) THEN 
    ALLOCATE(DstParamData%WindVeer(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%WindVeer.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%WindVeer = SrcParamData%WindVeer
ENDIF
IF (ALLOCATED(SrcParamData%Tint)) THEN
  i1_l = LBOUND(SrcParamData%Tint,1)
  i1_u = UBOUND(SrcParamData%Tint,1)
  IF (.NOT. ALLOCATED(DstParamData%Tint)) THEN 
    ALLOCATE(DstParamData%Tint(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Tint.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Tint = SrcParamData%Tint
ENDIF
    DstParamData%ka = SrcParamData%ka
    DstParamData%kb = SrcParamData%kb
    DstParamData%alpha = SrcParamData%alpha
    DstParamData%beta = SrcParamData%beta
IF (ALLOCATED(SrcParamData%zhub)) THEN
  i1_l = LBOUND(SrcParamData%zhub,1)
  i1_u = UBOUND(SrcParamData%zhub,1)
  IF (.NOT. ALLOCATED(DstParamData%zhub)) THEN 
    ALLOCATE(DstParamData%zhub(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%zhub.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%zhub = SrcParamData%zhub
ENDIF
IF (ALLOCATED(SrcParamData%drot)) THEN
  i1_l = LBOUND(SrcParamData%drot,1)
  i1_u = UBOUND(SrcParamData%drot,1)
  IF (.NOT. ALLOCATED(DstParamData%drot)) THEN 
    ALLOCATE(DstParamData%drot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%drot.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%drot = SrcParamData%drot
ENDIF
IF (ALLOCATED(SrcParamData%ti_par)) THEN
  i1_l = LBOUND(SrcParamData%ti_par,1)
  i1_u = UBOUND(SrcParamData%ti_par,1)
  IF (.NOT. ALLOCATED(DstParamData%ti_par)) THEN 
    ALLOCATE(DstParamData%ti_par(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%ti_par.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%ti_par = SrcParamData%ti_par
ENDIF
IF (ALLOCATED(SrcParamData%Layout)) THEN
  i1_l = LBOUND(SrcParamData%Layout,1)
  i1_u = UBOUND(SrcParamData%Layout,1)
  i2_l = LBOUND(SrcParamData%Layout,2)
  i2_u = UBOUND(SrcParamData%Layout,2)
  IF (.NOT. ALLOCATED(DstParamData%Layout)) THEN 
    ALLOCATE(DstParamData%Layout(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%Layout.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%Layout = SrcParamData%Layout
ENDIF
    DstParamData%NumDataLines = SrcParamData%NumDataLines
 END SUBROUTINE IfW_UserWind_CopyParam

 SUBROUTINE IfW_UserWind_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(IfW_UserWind_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'IfW_UserWind_DestroyParam'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%Vb)) THEN
  DEALLOCATE(ParamData%Vb)
ENDIF
IF (ALLOCATED(ParamData%z0)) THEN
  DEALLOCATE(ParamData%z0)
ENDIF
IF (ALLOCATED(ParamData%zmin)) THEN
  DEALLOCATE(ParamData%zmin)
ENDIF
IF (ALLOCATED(ParamData%WindDir)) THEN
  DEALLOCATE(ParamData%WindDir)
ENDIF
IF (ALLOCATED(ParamData%WindVeer)) THEN
  DEALLOCATE(ParamData%WindVeer)
ENDIF
IF (ALLOCATED(ParamData%Tint)) THEN
  DEALLOCATE(ParamData%Tint)
ENDIF
IF (ALLOCATED(ParamData%zhub)) THEN
  DEALLOCATE(ParamData%zhub)
ENDIF
IF (ALLOCATED(ParamData%drot)) THEN
  DEALLOCATE(ParamData%drot)
ENDIF
IF (ALLOCATED(ParamData%ti_par)) THEN
  DEALLOCATE(ParamData%ti_par)
ENDIF
IF (ALLOCATED(ParamData%Layout)) THEN
  DEALLOCATE(ParamData%Layout)
ENDIF
 END SUBROUTINE IfW_UserWind_DestroyParam

 SUBROUTINE IfW_UserWind_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(IfW_UserWind_ParameterType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'IfW_UserWind_PackParam'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! dT
      Re_BufSz   = Re_BufSz   + 1  ! Ttot
  Int_BufSz   = Int_BufSz   + 1     ! Vb allocated yes/no
  IF ( ALLOCATED(InData%Vb) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Vb upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vb)  ! Vb
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! z0 allocated yes/no
  IF ( ALLOCATED(InData%z0) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! z0 upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%z0)  ! z0
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! zmin allocated yes/no
  IF ( ALLOCATED(InData%zmin) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! zmin upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%zmin)  ! zmin
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! WindDir allocated yes/no
  IF ( ALLOCATED(InData%WindDir) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! WindDir upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%WindDir)  ! WindDir
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! WindVeer allocated yes/no
  IF ( ALLOCATED(InData%WindVeer) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! WindVeer upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%WindVeer)  ! WindVeer
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Tint allocated yes/no
  IF ( ALLOCATED(InData%Tint) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Tint upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Tint)  ! Tint
  END IF
      Re_BufSz   = Re_BufSz   + 1  ! ka
      Re_BufSz   = Re_BufSz   + 1  ! kb
      Re_BufSz   = Re_BufSz   + 1  ! alpha
      Re_BufSz   = Re_BufSz   + 1  ! beta
  Int_BufSz   = Int_BufSz   + 1     ! zhub allocated yes/no
  IF ( ALLOCATED(InData%zhub) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! zhub upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%zhub)  ! zhub
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! drot allocated yes/no
  IF ( ALLOCATED(InData%drot) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! drot upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%drot)  ! drot
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! ti_par allocated yes/no
  IF ( ALLOCATED(InData%ti_par) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! ti_par upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%ti_par)  ! ti_par
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Layout allocated yes/no
  IF ( ALLOCATED(InData%Layout) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Layout upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Layout)  ! Layout
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NumDataLines
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%dT
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%Ttot
      Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. ALLOCATED(InData%Vb) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vb,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vb,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%Vb)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Vb))-1 ) = PACK(InData%Vb,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Vb)
  END IF
  IF ( .NOT. ALLOCATED(InData%z0) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%z0,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%z0,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%z0)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%z0))-1 ) = PACK(InData%z0,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%z0)
  END IF
  IF ( .NOT. ALLOCATED(InData%zmin) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%zmin,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%zmin,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%zmin)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%zmin))-1 ) = PACK(InData%zmin,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%zmin)
  END IF
  IF ( .NOT. ALLOCATED(InData%WindDir) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WindDir,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WindDir,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%WindDir)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WindDir))-1 ) = PACK(InData%WindDir,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%WindDir)
  END IF
  IF ( .NOT. ALLOCATED(InData%WindVeer) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WindVeer,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WindVeer,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%WindVeer)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%WindVeer))-1 ) = PACK(InData%WindVeer,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%WindVeer)
  END IF
  IF ( .NOT. ALLOCATED(InData%Tint) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Tint,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Tint,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%Tint)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Tint))-1 ) = PACK(InData%Tint,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Tint)
  END IF
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%ka
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%kb
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%alpha
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%beta
      Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. ALLOCATED(InData%zhub) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%zhub,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%zhub,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%zhub)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%zhub))-1 ) = PACK(InData%zhub,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%zhub)
  END IF
  IF ( .NOT. ALLOCATED(InData%drot) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%drot,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%drot,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%drot)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%drot))-1 ) = PACK(InData%drot,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%drot)
  END IF
  IF ( .NOT. ALLOCATED(InData%ti_par) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ti_par,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ti_par,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%ti_par)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%ti_par))-1 ) = PACK(InData%ti_par,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%ti_par)
  END IF
  IF ( .NOT. ALLOCATED(InData%Layout) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Layout,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Layout,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Layout,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Layout,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%Layout)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Layout))-1 ) = PACK(InData%Layout,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Layout)
  END IF
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%NumDataLines
      Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE IfW_UserWind_PackParam

 SUBROUTINE IfW_UserWind_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(IfW_UserWind_ParameterType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'IfW_UserWind_UnPackParam'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      OutData%dT = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%Ttot = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vb not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vb)) DEALLOCATE(OutData%Vb)
    ALLOCATE(OutData%Vb(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vb.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%Vb)>0) OutData%Vb = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Vb))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Vb)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! z0 not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%z0)) DEALLOCATE(OutData%z0)
    ALLOCATE(OutData%z0(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%z0.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%z0)>0) OutData%z0 = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%z0))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%z0)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! zmin not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%zmin)) DEALLOCATE(OutData%zmin)
    ALLOCATE(OutData%zmin(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%zmin.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%zmin)>0) OutData%zmin = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%zmin))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%zmin)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WindDir not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WindDir)) DEALLOCATE(OutData%WindDir)
    ALLOCATE(OutData%WindDir(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WindDir.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%WindDir)>0) OutData%WindDir = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WindDir))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%WindDir)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WindVeer not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WindVeer)) DEALLOCATE(OutData%WindVeer)
    ALLOCATE(OutData%WindVeer(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WindVeer.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%WindVeer)>0) OutData%WindVeer = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%WindVeer))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%WindVeer)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Tint not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Tint)) DEALLOCATE(OutData%Tint)
    ALLOCATE(OutData%Tint(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Tint.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%Tint)>0) OutData%Tint = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Tint))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Tint)
    DEALLOCATE(mask1)
  END IF
      OutData%ka = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%kb = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%alpha = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%beta = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! zhub not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%zhub)) DEALLOCATE(OutData%zhub)
    ALLOCATE(OutData%zhub(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%zhub.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%zhub)>0) OutData%zhub = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%zhub))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%zhub)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! drot not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%drot)) DEALLOCATE(OutData%drot)
    ALLOCATE(OutData%drot(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%drot.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%drot)>0) OutData%drot = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%drot))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%drot)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! ti_par not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%ti_par)) DEALLOCATE(OutData%ti_par)
    ALLOCATE(OutData%ti_par(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%ti_par.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%ti_par)>0) OutData%ti_par = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%ti_par))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%ti_par)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Layout not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Layout)) DEALLOCATE(OutData%Layout)
    ALLOCATE(OutData%Layout(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Layout.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%Layout)>0) OutData%Layout = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Layout))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Layout)
    DEALLOCATE(mask2)
  END IF
      OutData%NumDataLines = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
 END SUBROUTINE IfW_UserWind_UnPackParam

END MODULE IfW_UserWind_Types
!ENDOFREGISTRYGENERATEDFILE
